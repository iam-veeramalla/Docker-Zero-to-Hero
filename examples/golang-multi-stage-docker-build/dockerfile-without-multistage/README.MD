# Optimizing Docker Images with Multi-Stage Builds

## Overview
This guide explains how multi-stage builds work in Docker to optimize image size, using Go as an example.

## Traditional Docker Build (Large Image)
```dockerfile
###########################################
# BASE IMAGE
###########################################

FROM ubuntu AS build

RUN apt-get update && apt-get install -y golang-go

ENV GO111MODULE=off

COPY . .

RUN CGO_ENABLED=0 go build -o /app .

ENTRYPOINT ["/app"]
```
### Breakdown
- Uses Ubuntu as the base image (~29MB).
- Installs Go (~500MB+).
- Copies source code and compiles it into an executable binary (`/app`).
- The final image size is **~600MB**.

## Optimized Multi-Stage Build (Small Image)
```dockerfile
###########################################
# BASE IMAGE (Build Stage)
###########################################

FROM ubuntu AS build

RUN apt-get update && apt-get install -y golang-go

ENV GO111MODULE=off

COPY . .

RUN CGO_ENABLED=0 go build -o /app .

############################################
# FINAL STAGE (Minimal Runtime)
############################################

FROM scratch

COPY --from=build /app /app

ENTRYPOINT ["/app"]
```
### Why is This Smaller?
1. **First stage (Ubuntu-based)**
   - Builds the executable binary using Ubuntu and Go.
   - The build container is **temporary** and discarded after compilation.

2. **Second stage (Scratch-based)**
   - Uses `scratch`, an empty base image (0KB).
   - Copies only the compiled binary (`/app`) from the first stage.
   - No OS, no package manager, no extra dependencies.

### Result
- **Final Image Size:** **~1.8MB** (only the Go binary).
- **No Ubuntu, No Go Compiler** in the final image.

## Understanding the Binary File
A **binary** is an executable file produced after compilation. In this case:
- `go build -o /app .` generates `/app`, which is a self-contained executable.
- The binary can run independently without Go or Ubuntu.

## Benefits of Multi-Stage Builds
âœ… **Reduces Image Size** â†’ From **600MB to 1.8MB**.
âœ… **Enhances Security** â†’ No extra tools, fewer vulnerabilities.
âœ… **Speeds Up Deployment** â†’ Smaller images load faster.
âœ… **Optimized Performance** â†’ Only the necessary binary is included.

## When to Use Multi-Stage Builds
Multi-stage builds are ideal for:
- **Compiled languages** like Go, Rust, and C++.
- **Reducing Docker image size** for production.
- **Minimizing attack surface** in containerized applications.

## Summary
| Step                | Base Image Used | Size     | Contents                         |
|--------------------|---------------|---------|---------------------------------|
| **Build Stage**    | Ubuntu        | ~600MB  | Go compiler, source code, binary |
| **Final Image**    | Scratch       | ~1.8MB  | Only the compiled binary (`/app`) |

### ðŸš€ Best Practice: Always Use Multi-Stage Builds for Optimized Docker Images! ðŸŽ¯

